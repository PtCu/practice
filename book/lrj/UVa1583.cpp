// 如果x加上x的各个数字之和得到y，就说x是y的生成元。
// 给出n（1≤n≤100000），求最小生成元。无解输出0。
// 例如，n = 216，121，2005时的解分别为198，0，1979。
// 【分析】本题看起来是个数学题，实则不然。假设所求生成元为m。
// 不难发现m < n。换句话说，只需枚举所有的m < n，看看有没有哪个数是n的生成元。
// 可惜这样做的效率并不高，因为每次计算一个n的生成元都需要枚举n - 1个数。
// 有没有更快的方法？聪明的读者也许已经想到了：只需一次性枚举100000内的所有正整数m，
// 标记“m加上m的各个数字之和得到的数有一个生成元是m”，最后查表即可。

#include <bits/stdc++.h>
const int XE=1e5+1;
int ans[XE];
int main(){
    for (int m = 1; m < XE;m++){
        int x = m;
        int y = m;
        while(y){
            x += y % 10;
            y /= 10;
        }
        if(ans[x]==0||m<ans[x]){    //最小生成元
            ans[x] = m;
        }
    }
    
}